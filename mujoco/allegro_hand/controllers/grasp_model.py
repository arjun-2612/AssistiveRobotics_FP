"""
Grasp Model - Section II.A
Implements the grasp matrix G that relates object motion to contact velocities.

Key equations:
- ċ = G^T ν  (Equation 1) - Contact velocities from object twist
- w = G f    (Equation 3) - Object wrench from contact forces
"""

import numpy as np
from typing import List, Tuple


class GraspMatrix:
    """
    Computes and manages the grasp matrix G ∈ R^(6x3n).
    
    The grasp matrix relates:
    - Object twist ν to contact velocities: ċ = G^T ν
    - Contact forces f to object wrench: w = G^T f
    """
    
    def __init__(self, n_contacts: int = 4):
        """
        Initialize grasp matrix builder.
        
        Args:
            n_contacts: Number of contact points
        """
        self.n_contacts = n_contacts
        self.G = None
        
    def compute_grasp_matrix(self, contact_positions: np.ndarray, object_position: np.ndarray) -> np.ndarray:
        """
        Compute grasp matrix G from contact positions.
        
        For hard-finger contacts (point contact with friction), each contact i contributes a 6x3 block to G:
        
        G_i = [I_3x3    ]  where r_i = c^[i] - p_o
              [skew(r_i)]
        
        Args:
            contact_positions: Contact positions in world frame (3n vector or list of n vectors)
            object_position: Object center position (3D vector)
            
        Returns:
            G: Grasp matrix (3nx6)
        """
        # Reshape if flat array
        if contact_positions.ndim == 1:
            contact_positions = contact_positions.reshape(-1, 3)
            
        assert contact_positions.shape[0] == self.n_contacts, \
            f"Expected {self.n_contacts} contacts, got {contact_positions.shape[0]}"
        
        G = np.zeros((6, 3 * self.n_contacts))
        for i in range(self.n_contacts):
            c_i = contact_positions[i]  # Contact position
            r_i = c_i - object_position # Position vector from object center to contact
            
            # Build G_i block (6x3)
            G[0:3, 3*i:3*i+3] = np.eye(3)   # Force contribution
            G[3:6, 3*i:3*i+3] = self._skew_symmetric(r_i)   # Bottom 3 rows: skew-symmetric of r_i (torque contribution)
            
        self.G = G
        return self.G
    
    @staticmethod
    def _skew_symmetric(v: np.ndarray) -> np.ndarray:
        """
        Create skew-symmetric matrix from vector.
        
        For v = [x, y, z], returns:
        [  0  -z   y ]
        [  z   0  -x ]
        [ -y   x   0 ]
        
        Used for cross product: skew(v) @ u = v x u
        
        Args:
            v: 3D vector
            
        Returns:
            3x3 skew-symmetric matrix
        """
        return np.array([
            [0, -v[2], v[1]],
            [v[2], 0, -v[0]],
            [-v[1], v[0], 0]
        ])
    
    def object_twist_to_contact_velocities(self, object_twist: np.ndarray) -> np.ndarray:
        """
        Map object twist to contact velocities (Equation 1).
        
        ċ = G^T ν
        
        Args:
            object_twist: Object twist ν ∈ R^6 [linear_vel, angular_vel]
            
        Returns:
            contact_velocities: ċ ∈ R^(3n)
        """
        assert self.G is not None, "Grasp matrix not computed yet"
        assert object_twist.shape == (6,), "Object twist must be 6D"
        
        # ċ = G^T ν
        contact_velocities = self.G.T @ object_twist
        
        return contact_velocities
    
    def contact_forces_to_object_wrench(self, contact_forces: np.ndarray) -> np.ndarray:
        """
        Map contact forces to object wrench (Equation 3).
        
        w = G^T f
        
        Args:
            contact_forces: f ∈ R^(3n) - forces at all contacts
            
        Returns:
            object_wrench: w ∈ R^6 [force, torque]
        """
        assert self.G is not None, "Grasp matrix not computed yet"
        assert contact_forces.shape == (3 * self.n_contacts,), \
            f"Expected {3 * self.n_contacts} force components"
        
        # w = G f
        object_wrench = self.G @ contact_forces
        
        return object_wrench
    
    def get_grasp_matrix(self) -> np.ndarray:
        """Return the current grasp matrix."""
        assert self.G is not None, "Grasp matrix not computed yet"
        return self.G.copy()
    
    def is_force_closure(self, tolerance: float = 1e-6) -> bool:
        """
        Check if the grasp achieves force closure.
        
        Force closure requires that the grasp matrix has full rank (rank = 6),
        meaning any object wrench can be generated by contact forces.
        
        Args:
            tolerance: Numerical tolerance for rank computation
            
        Returns:
            True if force closure is achieved
        """
        if self.G is None:
            return False
            
        rank = np.linalg.matrix_rank(self.G, tol=tolerance)
        return rank == 6
    
    def compute_f_star_in_Nullspace(self, f_star: np.ndarray) -> np.ndarray:
        """
        Compute the internal force component (nullspace of G).
        
        Internal forces squeeze the object without moving it.
        f_null_star = (I - G^T (G^T)+) f*
        
        Args:
            f_star: Total contact forces f ∈ R^(3n)
            
        Returns:
            Internal force component
        """
        assert self.G is not None, "Grasp matrix not computed yet"
        
        # Pseudoinverse of G_T
        G_T = self.G.T
        G_T_pinv = np.linalg.pinv(G_T)
        
        # Nullspace projector
        n_dim = 3 * self.n_contacts
        I = np.eye(n_dim)
        nullspace_proj = I - G_T @ G_T_pinv
        
        # Project forces into nullspace
        f_null_star = nullspace_proj @ f_star
        
        return f_null_star